modl = glm(Species ~ ., family = poisson, data = gala)
summary(modl)$coef[,1]
for (i in 1:5) {
eta = lmod$fit
mu = log(eta)
z = eta + (y-mu)/mu
w = 1/mu * ((1/mu)/(mu)) ^(-2)
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
modl = glm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent, family = poisson, data = gala)
summary(modl)$coef[,1]
gala_pois = glm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent, family = poisson, data = gala)
sumary(gala_pois)$coef
y = gala$Species
mu = y
eta = log(mu)
d_eta = 1/mu
v = mu
w = exp(eta)
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
for (i in 1:5) {
eta = lmod$fit
mu = log(eta)
z = eta + (y - mu)/mu
w = diag(as.vector(mu))
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
w
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
y = gala$Species
mu = y
eta = log(mu)
d_eta = 1/mu
v = mu
w = exp(eta)
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
for (i in 1:5) {
eta = lmod$fit
mu = log(eta)
z = eta + (y - mu)/mu
w = mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
sumary(gala_pois)$coef[,1]
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
for (i in 1:100) {
eta = lmod$fit
mu = log(eta)
z = eta + (y - mu)/mu
w = exp(eta)
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
y = gala$Species
mu = y
eta = log(mu)
d_eta = 1/mu
v = mu
w = exp(eta)
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
for (i in 1:100) {
eta = lmod$fit
mu = log(eta)
z = eta + (y - mu)/mu
w = exp(eta)
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
y = gala$Species
mu = y
eta = log(mu)
d_eta = 1/mu
v = mu
w = exp(eta)
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
for (i in 1:5) {
eta = lmod$fit
mu = log(eta)
z = eta + (y - mu)/mu
w = c(exp(eta))
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
y = gala$Species
mu = y
eta = log(mu)
d_eta = 1/mu
v = mu
w = mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
for (i in 1:5) {
eta = lmod$fit
mu = log(eta)
z = eta + (y - mu)/mu
w = c(exp(eta))
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
y = gala$Species
mu = y + 0.00001
eta = log(mu)
d_eta = 1/mu
v = mu
w = mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
for (i in 1:5) {
eta = lmod$fit
mu = log(eta)
z = eta + (y - mu)/mu
w = c(exp(eta))
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
y = gala$Species
mu = y + 0.00001
eta = log(mu)
d_eta = 1/mu
v = mu
w = mu
z = eta + (y - mu)/mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
for (i in 1:5) {
eta = lmod$fit
mu = log(eta)
z = eta + (y - mu)/mu
w = c(exp(eta))
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
y = gala$Species
mu = y + 0.00001
eta = log(mu)
d_eta = 1/mu
v = mu
w = mu
z = eta + (y - mu)/mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
for (i in 1:5) {
eta = lmod$fit
mu = log(eta)
z = eta + (y - mu)/mu
w = diag(as.vector(mu))
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
}
y = gala$Species
mu = y
eta = log(mu)
d_eta = 1/mu
v = mu
w = mu
z = eta + (y - mu)/mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
cat(i, coef(lmod), "\n")
coef(lmod)
sumary(gala_pois)$coef[,1]
eta = lmod$fit
eta = lmod$fit
mu = exp(eta)
z = eta + (y - mu)/mu
w = mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
coef(lmod)
dev = 2*sum(y * log(y) - y * eta - (y - exp(eta)))
dev
lmod
sumary(lmod)
eta = lmod$fit
mu = exp(eta)
z = eta + (y - mu)/mu
w = mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
coef(lmod)
dev = 2*sum(y * log(y) - y * eta - (y - exp(eta)))
dev
eta = lmod$fit
mu = exp(eta)
z = eta + (y - mu)/mu
w = mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
coef(lmod)
dev = 2*sum(y * log(y) - y * eta - (y - exp(eta)))
dev
eta = lmod$fit
mu = exp(eta)
z = eta + (y - mu)/mu
w = mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
coef(lmod)
dev = 2*sum(y * log(y) - y * eta - (y - exp(eta)))
dev
eta = lmod$fit
mu = exp(eta)
z = eta + (y - mu)/mu
w = mu
lmod = lm(z ~ Area + Elevation + Nearest + Scruz + Adjacent, weights = w, gala)
coef(lmod)
dev = 2*sum(y * log(y) - y * eta - (y - exp(eta)))
dev
sumary(gala_pois)$coef
sumamry(lmod)
summary(lmod)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
# initialize parameters
p1 = 0.5
p2 = 0.5
beta1 = 1
beta2 = 1
max_iter = 100
tolerance = 0.001
# generate for loop to iterate until convergence or the max nos of iterations
for (iter in 1:max_iter) {
# store parameteres for comparison
p1_old = p1
beta1_old = beta1
beta2_old = beta2
# Expectation step: calculate p_i1^(c) = p(z_i = 1|x_i, beta1, beta2)
f1 = dgamma(x, shape = alpha,  rate = beta1)
f2 = dgamma(x, shape = alpha,  rate = beta2)
p_i1 = (p1 * f1) / ((p1 * f1) + (p2 * f2))
# Maximization step: update p1, p2, beta1, and beta2
p1 = mean(p_i1)
p2 = 1 - p1
beta1 = (alpha * sum(1 - p_i1)) / (sum(p_i1 * x))
beta2 = (alpha * sum(1 - p_i1)) / (sum((1 - p_i1) * x))
# check for convergence
param_change <- max(abs(p1 - p1_old), abs(beta1 - beta1_old), abs(beta2 - beta2_old))
if (param_change < tolerance) {
cat("Converged at iteration:", iter, "\n")
break
}
}
# initialize parameters
p1 = 0.5
p2 = 0.5
beta1 = 1
beta2 = 1
max_iter = 100
tolerance = 0.001
x = dist
# generate for loop to iterate until convergence or the max nos of iterations
for (iter in 1:max_iter) {
# store parameteres for comparison
p1_old = p1
beta1_old = beta1
beta2_old = beta2
# Expectation step: calculate p_i1^(c) = p(z_i = 1|x_i, beta1, beta2)
f1 = dgamma(x, shape = alpha,  rate = beta1)
f2 = dgamma(x, shape = alpha,  rate = beta2)
p_i1 = (p1 * f1) / ((p1 * f1) + (p2 * f2))
# Maximization step: update p1, p2, beta1, and beta2
p1 = mean(p_i1)
p2 = 1 - p1
beta1 = (alpha * sum(1 - p_i1)) / (sum(p_i1 * x))
beta2 = (alpha * sum(1 - p_i1)) / (sum((1 - p_i1) * x))
# check for convergence
param_change <- max(abs(p1 - p1_old), abs(beta1 - beta1_old), abs(beta2 - beta2_old))
if (param_change < tolerance) {
cat("Converged at iteration:", iter, "\n")
break
}
}
# initialize parameters
set p1, p2, beta1, beta2 to an initial value
# initialize parameters
p1 = 0.5
p2 = 0.5
beta1 = 1
beta2 = 1
max_iter = 100
tolerance = 0.001
x = dist
# generate for loop to iterate until convergence or the max nos of iterations
for (iter in 1:max_iter) {
# store parameteres for comparison
p1_old = p1
beta1_old = beta1
beta2_old = beta2
# Expectation step: calculate p_i1^(c) = p(z_i = 1|x_i, beta1, beta2)
f1 = dgamma(x, shape = alpha,  rate = beta1)
f2 = dgamma(x, shape = alpha,  rate = beta2)
p_i1 = (p1 * f1) / ((p1 * f1) + (p2 * f2))
# Maximization step: update p1, p2, beta1, and beta2
p1 = mean(p_i1)
p2 = 1 - p1
beta1 = (20 * sum(1 - p_i1)) / (sum(p_i1 * x))
beta2 = (15 * sum(1 - p_i1)) / (sum((1 - p_i1) * x))
# check for convergence
param_change <- max(abs(p1 - p1_old), abs(beta1 - beta1_old), abs(beta2 - beta2_old))
if (param_change < tolerance) {
cat("Converged at iteration:", iter, "\n")
break
}
}
# initialize parameters
p1 = 0.5
p2 = 0.5
beta1 = 1
beta2 = 1
max_iter = 100
tolerance = 0.001
x = dist
alpha1 = 20
alpha2 = 15
# generate for loop to iterate until convergence or the max nos of iterations
for (iter in 1:max_iter) {
# store parameteres for comparison
p1_old = p1
beta1_old = beta1
beta2_old = beta2
# Expectation step: calculate p_i1^(c) = p(z_i = 1|x_i, beta1, beta2)
f1 = dgamma(x, shape = alpha1,  rate = beta1)
f2 = dgamma(x, shape = alpha2,  rate = beta2)
p_i1 = (p1 * f1) / ((p1 * f1) + (p2 * f2))
# Maximization step: update p1, p2, beta1, and beta2
p1 = mean(p_i1)
p2 = 1 - p1
beta1 = (alpha1 * sum(1 - p_i1)) / (sum(p_i1 * x))
beta2 = (alpha2 * sum(1 - p_i1)) / (sum((1 - p_i1) * x))
# check for convergence
param_change <- max(abs(p1 - p1_old), abs(beta1 - beta1_old), abs(beta2 - beta2_old))
if (param_change < tolerance) {
cat("Converged at iteration:", iter, "\n")
break
}
}
alpha1
beta1
x
dist
# nos of samples for each distribution
n1 = rbinom(1, 200, 0.4)
n2 = 200 - n1
# generating samples
dist1 = rgamma(n1, shape = 20, scale = 1/10)
dist2 = rgamma(n1, shape = 15, scale = 1/25)
dist = c(dist1, dist2)
hist(dist)
dist
# initialize parameters
p1 = 0.5
p2 = 0.5
beta1 = 1
beta2 = 1
max_iter = 100
tolerance = 0.001
x = dist
alpha1 = 20
alpha2 = 15
# generate for loop to iterate until convergence or the max nos of iterations
for (iter in 1:max_iter) {
# store parameteres for comparison
p1_old = p1
beta1_old = beta1
beta2_old = beta2
# Expectation step: calculate p_i1^(c) = p(z_i = 1|x_i, beta1, beta2)
f1 = dgamma(x, shape = alpha1,  rate = beta1)
f2 = dgamma(x, shape = alpha2,  rate = beta2)
p_i1 = (p1 * f1) / ((p1 * f1) + (p2 * f2))
# Maximization step: update p1, p2, beta1, and beta2
p1 = mean(p_i1)
p2 = 1 - p1
beta1 = (alpha1 * sum(1 - p_i1)) / (sum(p_i1 * x))
beta2 = (alpha2 * sum(1 - p_i1)) / (sum((1 - p_i1) * x))
# check for convergence
param_change <- max(abs(p1 - p1_old), abs(beta1 - beta1_old), abs(beta2 - beta2_old))
if (param_change < tolerance) {
cat("Converged at iteration:", iter, "\n")
break
}
}
(p1 * f1) + (p2 * f2)
f1
x
dgamma(x, shape = alpha1,  rate = beta1)
rgamma(x, shape = alpha1,  rate = beta1)
x
alpha1
beta1
beta1 = 1
# initialize parameters
p1 = 0.5
p2 = 0.5
beta1 = 1
beta2 = 1
max_iter = 100
tolerance = 0.001
x = dist
alpha1 = 20
alpha2 = 15
# generate for loop to iterate until convergence or the max nos of iterations
for (iter in 1:max_iter) {
# store parameteres for comparison
p1_old = p1
beta1_old = beta1
beta2_old = beta2
# Expectation step: calculate p_i1^(c) = p(z_i = 1|x_i, beta1, beta2)
f1 = dgamma(x, shape = alpha1,  rate = beta1)
f2 = dgamma(x, shape = alpha2,  rate = beta2)
p_i1 = (p1 * f1) / ((p1 * f1) + (p2 * f2))
# Maximization step: update p1, p2, beta1, and beta2
p1 = mean(p_i1)
p2 = 1 - p1
beta1 = (alpha1 * sum(1 - p_i1)) / (sum(p_i1 * x))
beta2 = (alpha2 * sum(1 - p_i1)) / (sum((1 - p_i1) * x))
# check for convergence
param_change = max(abs(p1 - p1_old), abs(beta1 - beta1_old), abs(beta2 - beta2_old))
if (param_change < tolerance) {
cat("Converged at iteration:", iter, "\n")
break
}
}
f1 = dgamma(x, shape = alpha1,  rate = beta1)
f1
beta1
# initialize parameters
p1 = 0.5
p2 = 0.5
beta1 = 1
beta2 = 1
max_iter = 100
tolerance = 0.001
x = dist
alpha1 = 20
alpha2 = 15
# generate for loop to iterate until convergence or the max nos of iterations
for (iter in 1:max_iter) {
# store parameteres for comparison
p1_old = p1
beta1_old = beta1
beta2_old = beta2
# Expectation step: calculate p_i1^(c) = p(z_i = 1|x_i, beta1, beta2)
f1 = dgamma(x, shape = alpha1,  rate = beta1_old)
f2 = dgamma(x, shape = alpha2,  rate = beta2_old)
p_i1 = (p1 * f1) / ((p1 * f1) + (p2 * f2))
# Maximization step: update p1, p2, beta1, and beta2
p1 = mean(p_i1)
p2 = 1 - p1
beta1 = (alpha1 * sum(1 - p_i1)) / (sum(p_i1 * x))
beta2 = (alpha2 * sum(1 - p_i1)) / (sum((1 - p_i1) * x))
# check for convergence
param_change = max(abs(p1 - p1_old), abs(beta1 - beta1_old), abs(beta2 - beta2_old))
if (param_change < tolerance) {
cat("Converged at iteration:", iter, "\n")
break
}
}
beta1_old
f1
p1 = 0.5
p2 = 0.5
beta1 = 1
beta2 = 1
max_iter = 100
tolerance = 0.001
x = dist
alpha1 = 20
alpha2 = 15
p1_old = p1
beta1_old = beta1
beta2_old = beta2
# Expectation step: calculate p_i1^(c) = p(z_i = 1|x_i, beta1, beta2)
f1 = dgamma(x, shape = alpha1,  rate = beta1_old)
f2 = dgamma(x, shape = alpha2,  rate = beta2_old)
p_i1 = (p1 * f1) / ((p1 * f1) + (p2 * f2))
# Maximization step: update p1, p2, beta1, and beta2
p1 = mean(p_i1)
p2 = 1 - p1
beta1 = (alpha1 * sum(1 - p_i1)) / (sum(p_i1 * x))
beta2 = (alpha2 * sum(1 - p_i1)) / (sum((1 - p_i1) * x))
beta2
f1
# initialize parameters
p1 = 0.5
p2 = 0.5
beta1 = 1
beta2 = 1
max_iter = 100
tolerance = 0.001
x = dist
alpha1 = 20
alpha2 = 15
# generate for loop to iterate until convergence or the max nos of iterations
for (iter in 1:max_iter) {
# store parameteres for comparison
p1_old = p1
beta1_old = beta1
beta2_old = beta2
# Expectation step: calculate p_i1^(c) = p(z_i = 1|x_i, beta1, beta2)
f1 = dgamma(x, shape = alpha1,  rate = beta1_old)
f2 = dgamma(x, shape = alpha2,  rate = beta2_old)
p_i1 = (p1 * f1) / ((p1 * f1) + (p2 * f2))
p_i1_old = p_i1
# Maximization step: update p1, p2, beta1, and beta2
p1 = mean(p_i1)
p2 = 1 - p1
beta1 = (alpha1 * sum(1 - p_i1)) / (sum(p_i1 * x))
beta2 = (alpha2 * sum(1 - p_i1)) / (sum((1 - p_i1) * x))
# check for convergence
if (p_i1 != p_i1_old) {
cat("Converged at iteration:", iter, "\n")
break
}
}
p_i1
p_i1_old
